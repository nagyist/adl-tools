note
	component:   "openEHR ADL Tools"
	description: "Abstract constrainer type for instances of comparable primitive types"
	keywords:    "archetype, comparable"
	author:      "Thomas Beale <thomas.beale@openehr.org>"
	support:     "http://www.openehr.org/issues/browse/AWB"
	copyright:   "Copyright (c) 2013- openEHR Foundation <http://www.openEHR.org>"
	license:     "Apache 2.0 License <http://www.apache.org/licenses/LICENSE-2.0.html>"

deferred class C_ORDERED [G -> COMPARABLE create default_create end]

inherit
	C_PRIMITIVE_OBJECT
		redefine
			default_create, constraint, assumed_value, as_string
		end

feature {NONE} -- Initialisation

	default_create
		do
			precursor
			create constraint.make (0)
		end

	make_interval (an_interval: INTERVAL [G])
			-- make single constraint with `an_interval'
		do
			default_create
			constraint.extend (an_interval)
		ensure
			constraint.has (an_interval)
		end

	make_value_list (a_values: LIST [G])
			-- make from a list of values
		require
			Values_valid: not a_values.is_empty
		do
			default_create
			across a_values as vals_csr loop
				constraint.extend (create {POINT_INTERVAL [G]}.make (vals_csr.item))
			end
		end

	make_value (v: G)
		do
			default_create
			constraint.extend (create {POINT_INTERVAL [G]}.make (v))
		end

feature -- Access

	constraint: ARRAYED_LIST [INTERVAL [G]]
			-- single constraint represented by this object; accommodates
			-- single interval, multiple interval, list of single values, mixed values / intervals

	assumed_value: detachable COMPARABLE

	single_value: G
			-- single value if single-valued
		do
			check attached constraint.first.lower as v then
				Result := v
			end
		end

feature -- Status Report

	any_allowed: BOOLEAN
			-- True if any value allowed - only type is constrained
		do
			Result := constraint.is_empty
		end

	valid_value (a_value: G): BOOLEAN
		do
			Result := any_allowed or across constraint as ivl_csr some ivl_csr.item.has (a_value) end
		end

	is_single_value: BOOLEAN
			-- true if constraint is a single value
		do
			Result := constraint.count = 1 and constraint.first.is_point
		end

feature -- Comparison

	c_value_conforms_to (other: like Current): BOOLEAN
			-- True if this node is a strict subset of `other'
		do
			Result := other.any_allowed or
				across constraint as ivl_csr all
					across other.constraint as other_ivl_csr some other_ivl_csr.item.contains (ivl_csr.item) end
				end
		end

	c_value_congruent_to (other: like Current): BOOLEAN
			-- True if this node is the same as `other'
		do
			Result := constraint.count = other.constraint.count and
				across constraint as ivl_csr all
					ivl_csr.item.is_equal (other.constraint.i_th (ivl_csr.cursor_index))
				end
		end

feature -- Modification

	add_value (a_val: G)
		do
			constraint.extend (create {POINT_INTERVAL [G]}.make (a_val))
		end

	add_interval (an_interval: INTERVAL [G])
		do
			constraint.extend (an_interval)
		end

	set_from_ui_string (a_str: STRING)
			-- make from a string (typically taken from the UI), which has the same
			-- contents as generated by the `_as_string' call
		local
			a_list: LIST[STRING]
			s, s_lower, s_upper: STRING
			ivl: INTERVAL [G]
		do
			a_list := a_str.split (',')
			across a_list as list_csr loop
--				s := list_csr.item
--				if s.item (1) = '|' and s.item (s.count) = '|' then
--					s := s.substring (2, s.count - 1)
--					if s.has_substring ("..") then
--						s_lower := s.substring (1, s.substring_index ("..", 1) - 1)
--						s_upper := s.substring (s.substring_index ("..", 1) + 1, s.count)

--						create {PROPER_INTERVAL[G]} ivl
--					-- must be just a single value with a relational operator
--					else
--					end
--				else
--					create {POINT_INTERVAL[G]} ivl.make (new_value (s))
--					constraint.extend (ivl)
--				end
			end
		end

feature -- Output

	as_string: STRING
			-- generate `constraint' as string
		do
			Result := constraint_as_string
			if attached {G} assumed_value as av then
				Result.append ("; " + format_value (av))
			end
		end

feature {NONE} -- Implementation

	constraint_as_string: STRING
			-- <precursor>
		do
			create Result.make_empty
			across constraint as ivl_csr loop
				if not ivl_csr.item.is_point then
					Result.append_character ('|')
				end
				Result.append (ivl_csr.item.as_string)
				if not ivl_csr.item.is_point then
					Result.append_character ('|')
				end
				if not ivl_csr.is_last then
					Result.append (", ")
				end
			end
		end

	format_value (a_val: G): STRING
		do
			Result := a_val.out
		end

end


